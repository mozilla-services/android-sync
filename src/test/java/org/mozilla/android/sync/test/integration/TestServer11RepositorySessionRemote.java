/* Any copyright is dedicated to the Public Domain.
   http://creativecommons.org/publicdomain/zero/1.0/ */

package org.mozilla.android.sync.test.integration;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.json.simple.parser.ParseException;
import org.junit.Before;
import org.junit.Test;
import org.mozilla.android.sync.test.helpers.ExpectSuccessGuidsSinceDelegate;
import org.mozilla.android.sync.test.helpers.ExpectSuccessRepositorySessionFetchRecordsDelegate;
import org.mozilla.android.sync.test.helpers.MockGlobalSessionCallback;
import org.mozilla.android.sync.test.helpers.MockPrefsGlobalSession;
import org.mozilla.android.sync.test.helpers.WaitHelper;
import org.mozilla.android.sync.test.integration.TestBasicFetch.LiveDelegate;
import org.mozilla.gecko.sync.CredentialsSource;
import org.mozilla.gecko.sync.CryptoRecord;
import org.mozilla.gecko.sync.GlobalSession;
import org.mozilla.gecko.sync.NonObjectJSONException;
import org.mozilla.gecko.sync.SyncConfiguration;
import org.mozilla.gecko.sync.SyncConfigurationException;
import org.mozilla.gecko.sync.Utils;
import org.mozilla.gecko.sync.crypto.CryptoException;
import org.mozilla.gecko.sync.crypto.KeyBundle;
import org.mozilla.gecko.sync.repositories.RepositorySession;
import org.mozilla.gecko.sync.repositories.Server11Repository;
import org.mozilla.gecko.sync.repositories.Server11RepositorySession;
import org.mozilla.gecko.sync.repositories.delegates.RepositorySessionCreationDelegate;
import org.mozilla.gecko.sync.repositories.domain.FormHistoryRecord;
import org.mozilla.gecko.sync.repositories.domain.Record;

/**
 * Test <code>Server11RepositorySession</code> against a remote (live) server.
 */
public class TestServer11RepositorySessionRemote implements CredentialsSource {
  // TODO: switch this to use a local server, with appropriate setup.
  static final String TEST_CLUSTER_URL  = "https://scl2-sync1283.services.mozilla.com/";
  static final String TEST_ACCOUNT      = "nalexander+test0425@mozilla.com";
  static final String TEST_USERNAME     = "6gnkjphdltbntwnrgvu46ey6mu7ncjdl";
  static final String TEST_PASSWORD     = "test0425";
  static final String TEST_USER_PASS    = TEST_USERNAME + ":" + TEST_PASSWORD;
  static final String TEST_SYNC_KEY     = "fuyx96ea8rkfazvjdfuqumupye"; // Weave.Identity.syncKey

  static final String TEST_CLIENT_GUID_PREFIX  = "testGuid";

  private KeyBundle syncKeyBundle;
  private MockGlobalSessionCallback callback;
  // We go to the trouble of using a session and its internal SyncConfiguration
  // because ClientRecordTerminator creates its URI by hand. By testing against
  // URIs generated by SyncConfiguration, we hope to keep the two in step.
  private GlobalSession session;

  @Override
  public String credentials() {
    return TEST_USERNAME + ":" + TEST_PASSWORD;
  }

  @Before
  public void setUp()
      throws IllegalStateException, NonObjectJSONException, IOException,
      ParseException, CryptoException, SyncConfigurationException, IllegalArgumentException, URISyntaxException {

    syncKeyBundle = new KeyBundle(TEST_USERNAME, TEST_SYNC_KEY);

    callback = new MockGlobalSessionCallback();
    session = new MockPrefsGlobalSession(SyncConfiguration.DEFAULT_USER_API, TEST_CLUSTER_URL, TEST_USERNAME, TEST_PASSWORD, null,
        syncKeyBundle, callback, null, null, null);
    session.config.clusterURL = new URI(TEST_CLUSTER_URL);
  }

  protected Map<String, FormHistoryRecord> generateRecords(final String collection, final String[] guids) {
    HashMap<String, FormHistoryRecord> records = new HashMap<String, FormHistoryRecord>();

    for (String guid : guids) {
      final FormHistoryRecord record = new FormHistoryRecord(guid, collection);
      record.fieldName  = "testFieldName:" + guid;
      record.fieldValue = "testFieldValue:" + guid;
      records.put(guid, record);
    }

    return records;
  }

  protected long doPut(final String collection, final Collection<FormHistoryRecord> records) throws Exception {
    long timestamp = -1;

    for (FormHistoryRecord record : records) {
      CryptoRecord rec = record.getEnvelope();
      rec.setKeyBundle(syncKeyBundle);
      rec.encrypt();

      final String RECORD_URL = session.config.wboURI(collection, record.guid).toString();
      LiveDelegate ld = TestBasicFetch.realLivePut(TEST_USERNAME, TEST_PASSWORD, RECORD_URL, rec);
      if (ld.testFailureIgnored) {
        return -1;
      }

      final String timestampString = ld.body();
      assertNotNull(timestampString);
      timestamp = Math.max(timestamp, Utils.decimalSecondsToMilliseconds(timestampString));
    }

    return timestamp;
  }

  protected Server11RepositorySession repoSession;

  protected Server11RepositorySession getSession(final String collection) throws Exception {
    WaitHelper.getTestWaiter().performWait(new Runnable() {
      @Override
      public void run() {
        Server11Repository repo;
        try {
          repo = new Server11Repository(TEST_CLUSTER_URL, TEST_USERNAME, collection, TestServer11RepositorySessionRemote.this);
        } catch (Exception e) {
          WaitHelper.getTestWaiter().performNotify(e);
          return;
        }
        repo.createSession(new RepositorySessionCreationDelegate() {
          @Override
          public void onSessionCreated(RepositorySession session) {
            TestServer11RepositorySessionRemote.this.repoSession = (Server11RepositorySession) session;
            WaitHelper.getTestWaiter().performNotify();
          }

          @Override
          public void onSessionCreateFailed(Exception ex) {
            WaitHelper.getTestWaiter().performNotify(ex);
          }

          @Override
          public RepositorySessionCreationDelegate deferredCreationDelegate() {
            return this;
          }
        }, null);
      }
    });

    return this.repoSession;
  }

  public Set<String> doGuidsSince(final String collection, final long timestamp) throws Exception {
    final Server11RepositorySession repoSession = getSession(collection);
    assertNotNull(session);

    final ExpectSuccessGuidsSinceDelegate delegate = new ExpectSuccessGuidsSinceDelegate(WaitHelper.getTestWaiter());

    WaitHelper.getTestWaiter().performWait(new Runnable() {
      @Override
      public void run() {
        repoSession.guidsSince(timestamp, delegate);
      }
    });
    repoSession.abort();

    return new HashSet<String>(delegate.guids);
  }

  protected Map<String, FormHistoryRecord> doFetch(final String collection, final String[] guids) throws Exception {
    final Server11RepositorySession repoSession = getSession(collection);
    assertNotNull(session);

    final ExpectSuccessRepositorySessionFetchRecordsDelegate delegate = new ExpectSuccessRepositorySessionFetchRecordsDelegate(WaitHelper.getTestWaiter());

    WaitHelper.getTestWaiter().performWait(new Runnable() {
      @Override
      public void run() {
        repoSession.fetch(guids, delegate);
      }
    });
    repoSession.abort();

    final Map<String, FormHistoryRecord> fetched = new HashMap<String, FormHistoryRecord>();

    for (Record r : delegate.fetchedRecords) {
      final CryptoRecord c = (CryptoRecord) r;
      c.keyBundle = syncKeyBundle;
      c.decrypt();
      final FormHistoryRecord f = new FormHistoryRecord();
      f.initFromEnvelope(c);
      // To make comparison easy.
      f.collection = collection;
      f.lastModified = 0;
      fetched.put(f.guid, f);
    }

    return fetched;
  }

  @Test
  public void testGuidsSince() throws Exception {
    final String COLLECTION = "test";

    final String[] GUIDS1 = new String[] { "guid1", "guid2" };
    final String[] GUIDS2 = new String[] { "guid2", "guid3" }; // Note guid2 is in both sets.

    final Collection<FormHistoryRecord> RECS1 = generateRecords(COLLECTION, GUIDS1).values(); // Records to be PUT to server.
    final Collection<FormHistoryRecord> RECS2 = generateRecords(COLLECTION, GUIDS2).values(); // Records to be PUT to server.

    // Put records -- doesn't matter what type of record.  This overwrites anything already on the server.
    final long timestamp1 = 1 + doPut(COLLECTION, RECS1);
    final long timestamp2 = 1 + doPut(COLLECTION, RECS1); // Note: putting this twice for timestamps.
    doPut(COLLECTION, RECS2);

    // All are modified after initial PUT.
    final Set<String> expected1 = new HashSet<String>();
    for (String guid : GUIDS1) {
      expected1.add(guid);
    }
    for (String guid : GUIDS2) {
      expected1.add(guid);
    }
    final Set<String> guidsSince1 = doGuidsSince(COLLECTION, timestamp1);
    assertEquals(expected1, guidsSince1);

    // Only second batch are modified after second PUT.
    final Set<String> expected2 = new HashSet<String>();
    for (String guid : GUIDS2) {
      expected2.add(guid);
    }
    final Set<String> guidsSince2 = doGuidsSince(COLLECTION, timestamp2);
    assertEquals(expected2, guidsSince2);

    // None modified after future time.
    final long timestamp3 = System.currentTimeMillis() + 12*60*1000;
    final Set<String> expected3 = new HashSet<String>();
    final Set<String> guidsSince3 = doGuidsSince(COLLECTION, timestamp3);
    assertEquals(expected3, guidsSince3);
  }

  @Test
  public void testFetch() throws Exception {
    final String COLLECTION = "test";

    final String[] GUIDS = new String[] { "guid1", "guid2", "guid3" };
    final Collection<FormHistoryRecord> RECS = generateRecords(COLLECTION, GUIDS).values(); // Records to be PUT to server.

    // Put records -- doesn't matter what type of record.  This overwrites anything already on the server.
    doPut(COLLECTION, RECS);

    final String[] GUIDS1 = new String[] { "guid1" };
    final Map<String, FormHistoryRecord> fetch1 = doFetch(COLLECTION, GUIDS1);
    final Map<String, FormHistoryRecord> expected1 = generateRecords(COLLECTION, GUIDS1);
    assertEquals(expected1, fetch1);

    final String[] GUIDS2a = new String[] { "guid1", "guid2", "missing" };
    final String[] GUIDS2b = new String[] { "guid1", "guid2" };
    final Map<String, FormHistoryRecord> fetch2 = doFetch(COLLECTION, GUIDS2a);
    final Map<String, FormHistoryRecord> expected2 = generateRecords(COLLECTION, GUIDS2b);
    assertEquals(expected2, fetch2);
  }
}
